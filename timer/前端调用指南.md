# è¯­éŸ³è¯†åˆ«æœåŠ¡å‰ç«¯è°ƒç”¨æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†è¯´æ˜äº†å¦‚ä½•åœ¨å‰ç«¯åº”ç”¨ä¸­è°ƒç”¨è¯­éŸ³è¯†åˆ«æœåŠ¡ï¼ŒåŒ…æ‹¬æ–‡ä»¶ä¸Šä¼ ã€è¯­éŸ³è¯†åˆ«å’Œç»“æœè·å–ç­‰å®Œæ•´æµç¨‹ã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹

### åŸºç¡€é…ç½®

```javascript
// åŸºç¡€é…ç½®
const API_BASE_URL = 'http://localhost:3000'; // æ ¹æ®å®é™…éƒ¨ç½²åœ°å€è°ƒæ•´
const API_ENDPOINTS = {
  // è¯­éŸ³è¯†åˆ«ç›¸å…³æ¥å£
  RECOGNIZE: '/api/speech-recognition/recognize',        // å®Œæ•´è¯†åˆ«æµç¨‹
  UPLOAD_ONLY: '/api/speech-recognition/upload',        // ä»…ä¸Šä¼ æ–‡ä»¶
  RECOGNIZE_URL: '/api/speech-recognition/recognize-url' // ä»URLè¯†åˆ«
};

// ç”¨æˆ·è®¤è¯
let userToken = null; // å­˜å‚¨ç”¨æˆ·ç™»å½•åçš„token
```

### ç”¨æˆ·è®¤è¯

åœ¨è°ƒç”¨è¯­éŸ³è¯†åˆ«APIä¹‹å‰ï¼Œéœ€è¦å…ˆè¿›è¡Œç”¨æˆ·ç™»å½•è·å–tokenï¼š

```javascript
/**
 * ç”¨æˆ·ç™»å½•
 * @param {string} phoneNumber - æ‰‹æœºå·
 * @param {string} password - å¯†ç 
 * @returns {Promise<Object>} ç™»å½•ç»“æœ
 */
async function userLogin(phoneNumber, password) {
  try {
    const response = await fetch(`${API_BASE_URL}/api/users/login`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ phoneNumber, password })
    });

    const result = await response.json();
    
    if (result.success) {
      userToken = result.data.token;
      localStorage.setItem('userToken', userToken); // ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨
      return result;
    } else {
      throw new Error(result.message);
    }
  } catch (error) {
    console.error('ç™»å½•å¤±è´¥:', error);
    throw error;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
try {
  const loginResult = await userLogin('18176606006', '123456');
  console.log('ç™»å½•æˆåŠŸ:', loginResult.data.user);
} catch (error) {
  console.error('ç™»å½•å¤±è´¥:', error.message);
}
```

## ğŸµ è¯­éŸ³è¯†åˆ«APIè°ƒç”¨

### 1. å®Œæ•´è¯­éŸ³è¯†åˆ«æµç¨‹

ä¸€æ¬¡æ€§å®Œæˆæ–‡ä»¶ä¸Šä¼ å’Œè¯­éŸ³è¯†åˆ«ï¼š

```javascript
/**
 * å®Œæ•´è¯­éŸ³è¯†åˆ«æµç¨‹
 * @param {File} audioFile - éŸ³é¢‘æ–‡ä»¶å¯¹è±¡
 * @returns {Promise<Object>} è¯†åˆ«ç»“æœ
 */
async function recognizeVoice(audioFile) {
  try {
    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    const allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/mp4', 'audio/aac', 'audio/flac'];
    if (!allowedTypes.includes(audioFile.type)) {
      throw new Error('ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼ï¼Œè¯·ä½¿ç”¨ MP3, WAV, M4A, AAC, FLAC æ ¼å¼');
    }

    // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆ10MBé™åˆ¶ï¼‰
    if (audioFile.size > 10 * 1024 * 1024) {
      throw new Error('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡10MB');
    }

    // åˆ›å»ºFormData
    const formData = new FormData();
    formData.append('audio', audioFile);

    // å‘é€è¯·æ±‚
    const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.RECOGNIZE}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${userToken}`
      },
      body: formData
    });

    const result = await response.json();
    
    if (result.success) {
      return {
        success: true,
        transcription: result.data.transcription,  // è¯†åˆ«æ–‡æœ¬
        audioUrl: result.data.audioUrl,           // éŸ³é¢‘æ–‡ä»¶URL
        ossKey: result.data.ossKey               // OSSå­˜å‚¨è·¯å¾„
      };
    } else {
      throw new Error(result.error || result.message);
    }
  } catch (error) {
    console.error('è¯­éŸ³è¯†åˆ«å¤±è´¥:', error);
    throw error;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const fileInput = document.getElementById('audioFile');
fileInput.addEventListener('change', async (event) => {
  const file = event.target.files[0];
  if (file) {
    try {
      console.log('å¼€å§‹è¯­éŸ³è¯†åˆ«...');
      const result = await recognizeVoice(file);
      console.log('è¯†åˆ«æˆåŠŸ:', result.transcription);
      console.log('éŸ³é¢‘URL:', result.audioUrl);
      
      // æ˜¾ç¤ºè¯†åˆ«ç»“æœ
      document.getElementById('result').textContent = result.transcription;
    } catch (error) {
      console.error('è¯†åˆ«å¤±è´¥:', error.message);
      alert(`è¯†åˆ«å¤±è´¥: ${error.message}`);
    }
  }
});
```

### 2. ä»…ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶

å¦‚æœåªéœ€è¦ä¸Šä¼ æ–‡ä»¶ï¼Œä¸è¿›è¡Œè¯†åˆ«ï¼š

```javascript
/**
 * ä»…ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶
 * @param {File} audioFile - éŸ³é¢‘æ–‡ä»¶å¯¹è±¡
 * @returns {Promise<Object>} ä¸Šä¼ ç»“æœ
 */
async function uploadAudioOnly(audioFile) {
  try {
    const formData = new FormData();
    formData.append('audio', audioFile);

    const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.UPLOAD_ONLY}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${userToken}`
      },
      body: formData
    });

    const result = await response.json();
    
    if (result.success) {
      return {
        success: true,
        audioUrl: result.data.audioUrl,
        ossKey: result.data.ossKey
      };
    } else {
      throw new Error(result.error || result.message);
    }
  } catch (error) {
    console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
    throw error;
  }
}
```

### 3. ä»URLè¯†åˆ«éŸ³é¢‘

å¦‚æœéŸ³é¢‘æ–‡ä»¶å·²ç»ä¸Šä¼ ï¼Œå¯ä»¥é€šè¿‡URLè¿›è¡Œè¯†åˆ«ï¼š

```javascript
/**
 * ä»URLè¯†åˆ«éŸ³é¢‘
 * @param {string} audioUrl - éŸ³é¢‘æ–‡ä»¶URL
 * @returns {Promise<Object>} è¯†åˆ«ç»“æœ
 */
async function recognizeFromUrl(audioUrl) {
  try {
    const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.RECOGNIZE_URL}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${userToken}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ audioUrl })
    });

    const result = await response.json();
    
    if (result.success) {
      return {
        success: true,
        transcription: result.data.transcription,
        audioUrl: result.data.audioUrl
      };
    } else {
      throw new Error(result.error || result.message);
    }
  } catch (error) {
    console.error('URLè¯†åˆ«å¤±è´¥:', error);
    throw error;
  }
}
```

## ğŸ¨ å®Œæ•´çš„å‰ç«¯ç¤ºä¾‹

### HTMLç»“æ„

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯­éŸ³è¯†åˆ«æ¼”ç¤º</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #333;
        }
        input, button {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            margin-top: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .result {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #007bff;
        }
        .error {
            border-left-color: #dc3545;
            background-color: #f8d7da;
            color: #721c24;
        }
        .success {
            border-left-color: #28a745;
            background-color: #d4edda;
            color: #155724;
        }
        .loading {
            text-align: center;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸµ è¯­éŸ³è¯†åˆ«æœåŠ¡</h1>
        
        <!-- ç”¨æˆ·ç™»å½• -->
        <div class="form-group">
            <h3>ğŸ” ç”¨æˆ·ç™»å½•</h3>
            <label for="phoneNumber">æ‰‹æœºå·:</label>
            <input type="tel" id="phoneNumber" placeholder="è¯·è¾“å…¥æ‰‹æœºå·" value="18176606006">
            
            <label for="password">å¯†ç :</label>
            <input type="password" id="password" placeholder="è¯·è¾“å…¥å¯†ç " value="123456">
            
            <button onclick="login()">ç™»å½•</button>
        </div>

        <!-- è¯­éŸ³è¯†åˆ« -->
        <div class="form-group">
            <h3>ğŸ¤ è¯­éŸ³è¯†åˆ«</h3>
            <label for="audioFile">é€‰æ‹©éŸ³é¢‘æ–‡ä»¶:</label>
            <input type="file" id="audioFile" accept="audio/*">
            
            <button onclick="startRecognition()" id="recognizeBtn" disabled>å¼€å§‹è¯†åˆ«</button>
        </div>

        <!-- ç»“æœæ˜¾ç¤º -->
        <div id="result" class="result" style="display: none;"></div>
    </div>

    <script src="speech-recognition.js"></script>
</body>
</html>
```

### JavaScriptå®ç°

```javascript
// speech-recognition.js

// åŸºç¡€é…ç½®
const API_BASE_URL = 'http://localhost:3000';
const API_ENDPOINTS = {
  LOGIN: '/api/users/login',
  RECOGNIZE: '/api/speech-recognition/recognize'
};

let userToken = null;

// é¡µé¢åŠ è½½å®Œæˆåæ£€æŸ¥æœ¬åœ°å­˜å‚¨çš„token
document.addEventListener('DOMContentLoaded', () => {
  const savedToken = localStorage.getItem('userToken');
  if (savedToken) {
    userToken = savedToken;
    updateUIAfterLogin();
  }
});

/**
 * ç”¨æˆ·ç™»å½•
 */
async function login() {
  const phoneNumber = document.getElementById('phoneNumber').value;
  const password = document.getElementById('password').value;
  
  if (!phoneNumber || !password) {
    showResult('è¯·è¾“å…¥æ‰‹æœºå·å’Œå¯†ç ', 'error');
    return;
  }

  try {
    showResult('æ­£åœ¨ç™»å½•...', 'loading');
    
    const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.LOGIN}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ phoneNumber, password })
    });

    const result = await response.json();
    
    if (result.success) {
      userToken = result.data.token;
      localStorage.setItem('userToken', userToken);
      showResult('ç™»å½•æˆåŠŸï¼', 'success');
      updateUIAfterLogin();
    } else {
      showResult(`ç™»å½•å¤±è´¥: ${result.message}`, 'error');
    }
  } catch (error) {
    showResult(`ç™»å½•å¤±è´¥: ${error.message}`, 'error');
  }
}

/**
 * æ›´æ–°ç™»å½•åçš„UIçŠ¶æ€
 */
function updateUIAfterLogin() {
  document.getElementById('recognizeBtn').disabled = false;
  document.getElementById('phoneNumber').disabled = true;
  document.getElementById('password').disabled = true;
}

/**
 * å¼€å§‹è¯­éŸ³è¯†åˆ«
 */
async function startRecognition() {
  const fileInput = document.getElementById('audioFile');
  const file = fileInput.files[0];
  
  if (!file) {
    showResult('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶', 'error');
    return;
  }

  // æ£€æŸ¥æ–‡ä»¶ç±»å‹
  const allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/mp4', 'audio/aac', 'audio/flac'];
  if (!allowedTypes.includes(file.type)) {
    showResult('ä¸æ”¯æŒçš„éŸ³é¢‘æ ¼å¼ï¼Œè¯·ä½¿ç”¨ MP3, WAV, M4A, AAC, FLAC æ ¼å¼', 'error');
    return;
  }

  // æ£€æŸ¥æ–‡ä»¶å¤§å°
  if (file.size > 10 * 1024 * 1024) {
    showResult('æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡10MB', 'error');
    return;
  }

  try {
    showResult('æ­£åœ¨è¯†åˆ«ä¸­ï¼Œè¯·ç¨å€™...', 'loading');
    
    const formData = new FormData();
    formData.append('audio', file);

    const response = await fetch(`${API_BASE_URL}${API_ENDPOINTS.RECOGNIZE}`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${userToken}`
      },
      body: formData
    });

    const result = await response.json();
    
    if (result.success) {
      showResult(`
        <h4>âœ… è¯†åˆ«æˆåŠŸï¼</h4>
        <p><strong>è¯†åˆ«ç»“æœ:</strong> ${result.data.transcription}</p>
        <p><strong>éŸ³é¢‘URL:</strong> <a href="${result.data.audioUrl}" target="_blank">${result.data.audioUrl}</a></p>
        <p><strong>OSSè·¯å¾„:</strong> ${result.data.ossKey}</p>
      `, 'success');
    } else {
      showResult(`è¯†åˆ«å¤±è´¥: ${result.error || result.message}`, 'error');
    }
  } catch (error) {
    showResult(`è¯†åˆ«å¤±è´¥: ${error.message}`, 'error');
  }
}

/**
 * æ˜¾ç¤ºç»“æœ
 */
function showResult(message, type = 'info') {
  const resultDiv = document.getElementById('result');
  resultDiv.innerHTML = message;
  resultDiv.className = `result ${type}`;
  resultDiv.style.display = 'block';
}

/**
 * æ–‡ä»¶é€‰æ‹©å˜åŒ–æ—¶å¯ç”¨è¯†åˆ«æŒ‰é’®
 */
document.getElementById('audioFile').addEventListener('change', (event) => {
  const file = event.target.files[0];
  const recognizeBtn = document.getElementById('recognizeBtn');
  
  if (file && userToken) {
    recognizeBtn.disabled = false;
  } else {
    recognizeBtn.disabled = true;
  }
});
```

## ğŸ“± ç§»åŠ¨ç«¯é€‚é…

### å½•éŸ³åŠŸèƒ½

```javascript
/**
 * ç§»åŠ¨ç«¯å½•éŸ³åŠŸèƒ½
 */
class AudioRecorder {
  constructor() {
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.isRecording = false;
  }

  /**
   * å¼€å§‹å½•éŸ³
   */
  async startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      this.mediaRecorder = new MediaRecorder(stream);
      this.audioChunks = [];
      
      this.mediaRecorder.ondataavailable = (event) => {
        this.audioChunks.push(event.data);
      };
      
      this.mediaRecorder.onstop = () => {
        const audioBlob = new Blob(this.audioChunks, { type: 'audio/wav' });
        const audioFile = new File([audioBlob], 'recording.wav', { type: 'audio/wav' });
        
        // è‡ªåŠ¨å¼€å§‹è¯†åˆ«
        this.recognizeRecording(audioFile);
      };
      
      this.mediaRecorder.start();
      this.isRecording = true;
      
      return true;
    } catch (error) {
      console.error('å½•éŸ³å¤±è´¥:', error);
      return false;
    }
  }

  /**
   * åœæ­¢å½•éŸ³
   */
  stopRecording() {
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.stop();
      this.isRecording = false;
      
      // åœæ­¢æ‰€æœ‰éŸ³é¢‘è½¨é“
      this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
    }
  }

  /**
   * è¯†åˆ«å½•éŸ³
   */
  async recognizeRecording(audioFile) {
    try {
      const result = await recognizeVoice(audioFile);
      console.log('å½•éŸ³è¯†åˆ«æˆåŠŸ:', result);
      // å¤„ç†è¯†åˆ«ç»“æœ...
    } catch (error) {
      console.error('å½•éŸ³è¯†åˆ«å¤±è´¥:', error);
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const recorder = new AudioRecorder();

// å¼€å§‹å½•éŸ³æŒ‰é’®
document.getElementById('startRecord').addEventListener('click', () => {
  recorder.startRecording();
});

// åœæ­¢å½•éŸ³æŒ‰é’®
document.getElementById('stopRecord').addEventListener('click', () => {
  recorder.stopRecording();
});
```

## ğŸ”§ é”™è¯¯å¤„ç†

### å¸¸è§é”™è¯¯åŠè§£å†³æ–¹æ¡ˆ

```javascript
/**
 * é”™è¯¯å¤„ç†å·¥å…·
 */
class ErrorHandler {
  static handle(error, context = '') {
    console.error(`${context} é”™è¯¯:`, error);
    
    let userMessage = 'æ“ä½œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•';
    
    if (error.response) {
      // HTTPé”™è¯¯
      switch (error.response.status) {
        case 401:
          userMessage = 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•';
          // æ¸…é™¤æœ¬åœ°token
          localStorage.removeItem('userToken');
          userToken = null;
          break;
        case 400:
          userMessage = 'è¯·æ±‚å‚æ•°é”™è¯¯ï¼Œè¯·æ£€æŸ¥è¾“å…¥';
          break;
        case 413:
          userMessage = 'æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº10MBçš„æ–‡ä»¶';
          break;
        case 500:
          userMessage = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
          break;
        default:
          userMessage = `è¯·æ±‚å¤±è´¥ (${error.response.status})`;
      }
    } else if (error.request) {
      // ç½‘ç»œé”™è¯¯
      userMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®';
    } else if (error.message) {
      // å…¶ä»–é”™è¯¯
      userMessage = error.message;
    }
    
    // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
    showResult(userMessage, 'error');
    
    return userMessage;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
try {
  const result = await recognizeVoice(audioFile);
  // å¤„ç†æˆåŠŸç»“æœ...
} catch (error) {
  ErrorHandler.handle(error, 'è¯­éŸ³è¯†åˆ«');
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. æ–‡ä»¶é¢„å¤„ç†

```javascript
/**
 * éŸ³é¢‘æ–‡ä»¶é¢„å¤„ç†
 */
class AudioPreprocessor {
  /**
   * å‹ç¼©éŸ³é¢‘æ–‡ä»¶
   */
  static async compressAudio(audioFile, targetSize = 5 * 1024 * 1024) {
    return new Promise((resolve) => {
      const audio = new Audio();
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      audio.onloadedmetadata = () => {
        // è®¡ç®—å‹ç¼©å‚æ•°
        const duration = audio.duration;
        const targetBitrate = (targetSize * 8) / duration;
        
        // åˆ›å»ºå‹ç¼©åçš„éŸ³é¢‘
        const compressedFile = new File([audioFile], audioFile.name, {
          type: 'audio/mp3',
          lastModified: Date.now()
        });
        
        resolve(compressedFile);
      };
      
      audio.src = URL.createObjectURL(audioFile);
    });
  }
  
  /**
   * æ£€æŸ¥éŸ³é¢‘è´¨é‡
   */
  static checkAudioQuality(audioFile) {
    return new Promise((resolve) => {
      const audio = new Audio();
      
      audio.onloadedmetadata = () => {
        const quality = {
          duration: audio.duration,
          size: audioFile.size,
          format: audioFile.type,
          isValid: audio.duration > 0 && audio.duration <= 180 // 3åˆ†é’Ÿé™åˆ¶
        };
        
        resolve(quality);
      };
      
      audio.src = URL.createObjectURL(audioFile);
    });
  }
}
```

### 2. æ‰¹é‡å¤„ç†

```javascript
/**
 * æ‰¹é‡è¯­éŸ³è¯†åˆ«
 */
class BatchProcessor {
  constructor() {
    this.queue = [];
    this.processing = false;
    this.maxConcurrent = 3; // æœ€å¤§å¹¶å‘æ•°
  }
  
  /**
   * æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—
   */
  addTask(audioFile) {
    return new Promise((resolve, reject) => {
      this.queue.push({
        file: audioFile,
        resolve,
        reject
      });
      
      this.processQueue();
    });
  }
  
  /**
   * å¤„ç†é˜Ÿåˆ—
   */
  async processQueue() {
    if (this.processing || this.queue.length === 0) return;
    
    this.processing = true;
    
    while (this.queue.length > 0) {
      const batch = this.queue.splice(0, this.maxConcurrent);
      
      const promises = batch.map(async (task) => {
        try {
          const result = await recognizeVoice(task.file);
          task.resolve(result);
        } catch (error) {
          task.reject(error);
        }
      });
      
      await Promise.all(promises);
    }
    
    this.processing = false;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const batchProcessor = new BatchProcessor();

// æ‰¹é‡æ·»åŠ æ–‡ä»¶
const files = fileInput.files;
for (let file of files) {
  batchProcessor.addTask(file)
    .then(result => console.log('è¯†åˆ«æˆåŠŸ:', result))
    .catch(error => console.error('è¯†åˆ«å¤±è´¥:', error));
}
```

## ğŸ§ª æµ‹è¯•å»ºè®®

### 1. åŠŸèƒ½æµ‹è¯•

```javascript
/**
 * åŠŸèƒ½æµ‹è¯•å¥—ä»¶
 */
class TestSuite {
  static async runAllTests() {
    console.log('ğŸ§ª å¼€å§‹è¿è¡Œæµ‹è¯•å¥—ä»¶...');
    
    const tests = [
      this.testLogin,
      this.testFileUpload,
      this.testRecognition,
      this.testErrorHandling
    ];
    
    let passed = 0;
    let failed = 0;
    
    for (const test of tests) {
      try {
        await test();
        console.log(`âœ… ${test.name} é€šè¿‡`);
        passed++;
      } catch (error) {
        console.error(`âŒ ${test.name} å¤±è´¥:`, error.message);
        failed++;
      }
    }
    
    console.log(`\nğŸ“Š æµ‹è¯•ç»“æœ: ${passed} é€šè¿‡, ${failed} å¤±è´¥`);
    return { passed, failed };
  }
  
  static async testLogin() {
    const result = await userLogin('18176606006', '123456');
    if (!result.success) throw new Error('ç™»å½•æµ‹è¯•å¤±è´¥');
  }
  
  static async testFileUpload() {
    // åˆ›å»ºæµ‹è¯•éŸ³é¢‘æ–‡ä»¶
    const testFile = new File(['test audio content'], 'test.wav', { type: 'audio/wav' });
    const result = await uploadAudioOnly(testFile);
    if (!result.success) throw new Error('æ–‡ä»¶ä¸Šä¼ æµ‹è¯•å¤±è´¥');
  }
  
  static async testRecognition() {
    // æµ‹è¯•è¯†åˆ«åŠŸèƒ½
    const testFile = new File(['test audio content'], 'test.wav', { type: 'audio/wav' });
    const result = await recognizeVoice(testFile);
    if (!result.success) throw new Error('è¯­éŸ³è¯†åˆ«æµ‹è¯•å¤±è´¥');
  }
  
  static async testErrorHandling() {
    // æµ‹è¯•é”™è¯¯å¤„ç†
    try {
      await recognizeVoice(null);
      throw new Error('åº”è¯¥æŠ›å‡ºé”™è¯¯ä½†æ²¡æœ‰');
    } catch (error) {
      // é¢„æœŸä¼šæŠ›å‡ºé”™è¯¯
      console.log('é”™è¯¯å¤„ç†æµ‹è¯•é€šè¿‡');
    }
  }
}

// è¿è¡Œæµ‹è¯•
// TestSuite.runAllTests();
```

## ğŸ“š æ€»ç»“

æœ¬æŒ‡å—æä¾›äº†å®Œæ•´çš„è¯­éŸ³è¯†åˆ«æœåŠ¡å‰ç«¯è°ƒç”¨æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

1. **ç”¨æˆ·è®¤è¯** - ç™»å½•è·å–token
2. **æ–‡ä»¶ä¸Šä¼ ** - æ”¯æŒå¤šç§éŸ³é¢‘æ ¼å¼
3. **è¯­éŸ³è¯†åˆ«** - å®Œæ•´çš„è¯†åˆ«æµç¨‹
4. **é”™è¯¯å¤„ç†** - å®Œå–„çš„é”™è¯¯å¤„ç†æœºåˆ¶
5. **æ€§èƒ½ä¼˜åŒ–** - æ–‡ä»¶é¢„å¤„ç†å’Œæ‰¹é‡å¤„ç†
6. **æµ‹è¯•æ–¹æ¡ˆ** - åŠŸèƒ½æµ‹è¯•å¥—ä»¶

æŒ‰ç…§æœ¬æŒ‡å—å®ç°ï¼Œå‰ç«¯åº”ç”¨å°±èƒ½æ­£ç¡®è°ƒç”¨è¯­éŸ³è¯†åˆ«æœåŠ¡ï¼Œä¸ºç”¨æˆ·æä¾›æµç•…çš„è¯­éŸ³è¯†åˆ«ä½“éªŒã€‚

## ğŸ”— ç›¸å…³é“¾æ¥

- [é€šä¹‰åƒé—®ASR APIæ–‡æ¡£](https://help.aliyun.com/zh/dashscope/developer-reference/api-details)
- [é˜¿é‡Œäº‘OSSæ–‡æ¡£](https://help.aliyun.com/zh/oss/)
- [Web Audio APIæ–‡æ¡£](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Audio_API)
